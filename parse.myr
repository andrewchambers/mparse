use std

use "ast"
use "stab"
use "tok"
use "tokdefs"
use "type"
use "types"
use "node"
use "util"

pkg parse =
	const tsfile	: (ts : tokstream# -> file#)
;;

const tsfile = {ts
	var f
	var t : tok
	var vis : vis = `Visintern

	/* initialize the parser and file state */
	f = std.mk([
		.uses = [][:],
		.libs = [][:],
		.extlibs = [][:],
		.dcls = [][:],
		.extinit = [][:],
		.init = `std.None,
		.globls = mkstab(),
		.builtin = mkstab(),
		.ns = std.mkht(std.strhash, std.streq),
	])
	f.globls.super = `std.Some f.builtin

	/* parse */
	optendlns(ts)
	while true
		match tokpeek(ts)
		| (l, `Teof):	break
		| (l, `Tuse):	usestmt(ts, f)
		| (l, `Tpkg):	pkgdef(ts, f)
		| (l, `Ttrait):	traitdef(ts, f)
		| (l, `Ttype):	tydef(ts, f)
		| (l, `Tendln):	endlns(ts)
		| (l, tok):	
			if !vardcl(ts, f, true, vis)
				err(l, "invalid top level item near {}", tok)
			;;
		;;
	;;
	-> f
}

const usestmt = {ts, f
	match toknext(ts)
	| (l, `Tuse): /* ok */
	| (l, t):	err(l, "unexpected token in use {}\n", t)
	;;

	match toknext(ts)
	| (l, `Tstrlit str):	std.slpush(&f.uses, `Ulocal str)
	| (l, `Tident id):	std.slpush(&f.uses, `Ulib id)
	| (l, t):	err(l, "unexpected {} after use\n", t)
	;;
}

const pkgdef = {ts, f
	std.fatal("unimplemented pkg\n")
}

const traitdef = {ts, f
	std.fatal("unimplemented trait\n")
}

const tydef = {ts, f
	std.fatal("unimplemented type\n")
}

const vardcl = {ts, f, isglobl, vis
	var dcl : dcl
	var hadattr

	/* attributes */
	dcl = [
		.id = f.dcls.len,
		.vis = vis,
		.init = `std.None,
		.tr = `std.None,
		.isglobl = isglobl,
	]

	hadattr = dclattrs(ts, &dcl)
	/* attributes (const | var) */
	match tokpeek(ts)
	| (l, `Tvar):	dcl.isconst = false
	| (l, `Tconst):	dcl.isconst = true
	| (l, `Tgeneric):	
		dcl.isconst = true
		dcl.isgeneric = true
	| (l, badtok):
		if hadattr
			err(l, "unexpected {} in declaration, got {}\n", badtok)
		else
			-> false
		;;
	;;
	if !dcltag(ts, &dcl)
		if hadattr
		else
			-> false
		;;
	;;
	dclname(ts, &dcl)
	dcltype(ts, &dcl)
	dclinit(ts, &dcl)
	std.slpush(&f.dcls, std.mk(dcl))
	-> true
}


const dclname = {ts, dcl : dcl#
	/* attributes (const | var) name */
	match name(ts)
	| `std.Some n:
		if n.ns.len > 0 && !dcl.isextern
			std.fatal("only extern decls may provide namespaces\n")
		;;
		dcl.name = n
	| `std.None:	
		std.fatal("expected name in decl, got {}\n", tokpeekt(ts))
	;;
}

const dcltype = {ts, dcl
	match tokpeek(ts)
	| (l, `Tcolon):
		toknext(ts)
		match tyname(ts)
		| `std.Some t:	dcl.ty = t
		| `std.None:	err(l, "expected type after ':'\n")
		;;
	| (l, _):
		dcl.ty = mktyvar(l)
	;;
}

const dclinit = {ts, dcl
	match tokpeek(ts)
	| (l, `Tasn):
		toknext(ts)
		match expr(ts)
		| `std.Some e:	dcl.init = `std.Some e
		| `std.None:	err(l, "expected initializer after '='\n")
		;;
		-> true
	| tok:	
		dcl.init = `std.None
	;;

	-> false
}

const expr = {ts
	-> prefixexpr(ts)
}

const prefixexpr = {ts
	match toknext(ts)
	| (l, `Tinc):	
		match prefixexpr(ts)
		| `std.Some e:	-> `std.Some mkexpr(l, `Opreinc e)
		| `std.None:	-> `std.None
		;;
	| (l, `Tdec):
		match prefixexpr(ts)
		| `std.Some e:	-> `std.Some mkexpr(l, `Opredec e)
		|`std.None:	-> `std.None
		;;
	| (l, `Tband):
		match prefixexpr(ts)
		| `std.Some e:	-> `std.Some mkexpr(l, `Oaddr e)
		|`std.None:	-> `std.None
		;;
	| (l, `Tlnot):
		match prefixexpr(ts)
		| `std.Some e:	-> `std.Some mkexpr(l, `Olnot e)
		|`std.None:	-> `std.None
		;;
	| (l, `Tbnot):
		match prefixexpr(ts)
		| `std.Some e:	-> `std.Some mkexpr(l, `Obnot e)
		|`std.None:	-> `std.None
		;;
	| (l, `Tminus):
		match prefixexpr(ts)
		| `std.Some e:	-> `std.Some mkexpr(l, `Oneg e)
		|`std.None:	-> `std.None
		;;
	| (l, `Tplus):
		match prefixexpr(ts)
		| `std.Some e:	-> `std.Some e
		|`std.None:	-> `std.None
		;;
	| _:	
		tokunget(ts)
		-> postfixexpr(ts)
	;;
}

const postfixexpr = {ts
	var e

	match atomicexpr(ts)
	| `std.Some r:	e = r
	| `std.None:	-> `std.None
	;;

	while true
		match toknext(ts)
		| (l, `Tdot):	
			match toknext(ts)
			| (ml, `Tident memb):	e = mkexpr(l, `Omemb (e, memb))
			| (ml, badtok):	err(ml, "expected member after '.', got {}\n", badtok)
			;;
		| (l, `Tinc):	e = mkexpr(l, `Opostinc e)
		| (l, `Tdec):	e = mkexpr(l, `Opostdec e)
		| (l, `Tderef):	e = mkexpr(l, `Oderef e)
		| (l, `Tosqbrac):	e = idxexpr(ts, e)
		| (l, `Toparen):	e = callexpr(ts, e)
		| tok:	
			std.put("unget: {}\n", tok)
			tokunget(ts)
			break
		;;
	;;
	-> `std.Some e
}

const idxexpr = {ts : tokstream#, base
	var hadsl
	var lo, hi
	var loc

	loc = ts.loc

	/* open [ is consumed by caller */

	match expr(ts)
	| `std.Some e:	lo = `std.Some e
	| `std.None:	lo = `std.None
	;;

	hadsl = false
	match tokpeek(ts)
	| (l, `Tcolon):
		toknext(ts)
		hadsl = true
		match expr(ts)
		| `std.Some e:	hi = `std.Some e
		| `std.None:	hi = `std.None
		;;
	| (l, tok):
		match lo
		| `std.Some _:	/* ok */
		| `std.None:	err(l, "expected index in expr, got {}\n", tok)
		;;

	;;

	match toknext(ts)
	| (_, `Tcsqbrac):	/* ok */
	| (l, badtok):	err(l, "expected ']' after indexer, got {}\n", badtok)
	;;

	if hadsl
		-> mkexpr(loc, `Oslice (base, lo, hi))
	else
		match lo
		| `std.Some e:	-> mkexpr(loc, `Oidx (base, e))
		| `std.None:	std.die("should be unreachable\n")
		;;
	;;

}

const callexpr = {ts, e
	var args
	/* open ) is consumed by caller */

	args = callargs(ts)

	match toknext(ts)
	| (_, `Tcparen):	/* ok */
	| (l, badtok):	err(l, "expected ')' after call, got {}\n", badtok)
	;;
	
	-> mkexpr(ts.loc, `Ocall (e, args))

}

const callargs = {ts
	var args

	args = [][:]
	match expr(ts)
	| `std.None:	-> args
	| `std.Some e:	std.slpush(&args, e)
	;;

	while true
		match toknext(ts)
		| (l, `Tcomma):
			match expr(ts)
			| `std.Some e:	std.slpush(&args, e)
			| `std.None:	err(l, "expected expression after ',' in function args\n")
			;;
		| _:
			tokunget(ts)
			break
		;;
	;;
	-> args
}

const atomicexpr = {ts
	var e

	match toknext(ts)
	| (l, `Tgap):		e = `std.Some mkexpr(l, `Ogap)
	| (l, `Tident n):	e = `std.Some mkexpr(l, `Ovar [.ns="", .name=n])
	| (l, `Tintlit i):	e = `std.Some mkexpr(l, `Olit `Lint i)
	| (l, `Tstrlit s):	e = `std.Some mkexpr(l, `Olit `Lstr s)
	| (l, `Tfltlit f):	e = `std.Some mkexpr(l, `Olit `Lflt f)
	| (l, `Tchrlit c):	e = `std.Some mkexpr(l, `Olit `Lchr c)
	| (l, `Tboollit b):	e = `std.Some mkexpr(l, `Olit `Lbool b)
	| (l, `Tvoidlit):	e = `std.Some mkexpr(l, `Olit `Lvoid)
	| (l, `Tsizeof):	e = sizeofexpr(ts, l)
	| _:
		tokunget(ts)
		e = `std.None
	;;

	-> e
}

const sizeofexpr = {ts, loc
	var e

	match toknext(ts)
	| (_, `Toparen):	/* ok */
	| (l, badtok):	err(l, "expected '(' after sizeof, got {}\n", badtok)
	;;

	match tyname(ts)
	| `std.Some ty:	e = mkexpr(loc, `Osize ty)
	| `std.None:	err(ts.loc, "expected type in sizeof, got {}\n", tokpeekt(ts))
	;;

	match toknext(ts)
	| (_, `Toparen):	/* ok */
	| (l, badtok):	err(l, "expected '(' after sizeof, got {}\n", badtok)
	;;

	-> `std.Some e
}

const dclattrs = {ts, dcl
	var hadattr

	hadattr = false
	while true
		match tokpeek(ts)
		| (_, `Tattr `Attrpkglocal):	dcl.ispkglocal = true
		| (_, `Tattr `Attrextern):	dcl.isextern = true
		| (_, `Tattr `Attrnoret):	dcl.isnoret = true
		| _:	break
		;;
		toknext(ts)
		hadattr = true
	;;
	-> hadattr
}

const dcltag = {ts, dcl
	/* attributes (const | var) */
	match tokpeek(ts)
	| (_, `Tvar):	dcl.isconst = false
	| (_, `Tconst):	dcl.isconst = true
	| (_, `Tgeneric):	
		dcl.isconst = true
		dcl.isgeneric = true
	| (l, badtok):
		-> false
	;;
	toknext(ts)
	-> true
}

const name = {ts -> std.option(name)
	var ns, n

	match tokpeek(ts)
	| (l, `Tident id):	n = id
	| (l, tok):	-> `std.None
	;;
	toknext(ts)

	match tokpeek(ts)
	| (l, `Tdot):	ns = n
	| (l, _):	-> `std.Some [.ns = "", .name = n]
	;;
	toknext(ts)

	match tokpeek(ts)
	| (l, `Tident id):	n = id
	| (l, tok):	err(l, "expected after '.', got {}\n", tok)
	;;
	toknext(ts)

	-> `std.Some [.ns=ns, .name=n]
}

const tyname = {ts
	-> `std.None
}

const optendlns = {ts
	while true
		match tokpeek(ts)
		| (l, `Tendln): toknext(ts)
		| _:    break
		;;
	;;
}

const endlns = {ts
	match tokpeek(ts)
	| (l, `Tendln): optendlns(ts)
	| (l, tok):	err(l, "expected \\n, got {}\n", tok)
	;;
	-> true
}
